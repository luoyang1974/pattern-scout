# 方案一

## 一、前置：从旗杆到旗面候选

已知旗杆区间 `[t0, t1]`（方向 D=+1/-1）。在 `t1+1` 起，向右扩窗形成候选 `[s, e]`，同时只做**三项硬过滤**（全部是“相对量”，跨周期稳健）：

- **波动收敛**：`ATR_ratio = mean(TR[s:e])/mean(TR[t0:t1]) ≤ 0.70`
- **量能收缩**：`Vol_ratio = mean(V[s:e])/mean(V[t0:t1]) ≤ 0.80` 且 `mean(V[s:e]) ≤ VOL20`
- **回撤受限**：`Retrace = (maxH[s:e]-minL[s:e]) / |close[t1]-open[t0]| ≤ 0.45`

时间约束：`FlagBars = e-s+1 ∈ [ceil(PoleBars/2), 2*PoleBars]`（默认上限不超过 20 根）。

> 到这一步，我们拿到“**合格的整理窗口**” `[s, e]`，下一步才区分矩形/三角。

------

## 二、同一套“分位通道”刻画几何（不做拟合）

在 `[s, e]` 上构建**分位通道**（比拟合直线更稳健）：

- 上沿 `U_t = rolling_q(high, 95%, k)`
- 下沿 `L_t = rolling_q(low,  5%, k)`
- 宽度 `W_t = U_t - L_t`，令
  - `W_med = median(W_t)`
  - `width_norm = W_med / PoleAmp`，要求 `0.15 ≤ width_norm ≤ 0.45`（太窄是假横盘，太宽不算旗面）

仅需再算两件事：

- **平行度**：`parallel = |slope(U) - slope(L)| / ATR14_per_bar`
- **收敛度**：`converge = median(W_t_last_half) / median(W_t_first_half)`（<1 表示在收敛）

> `slope(·)` 用线性回归斜率即可；`ATR14_per_bar = ATR14 / 1bar` 用来归一。

------

## 三、统一判定准则（矩形 vs 三角）

在同一窗口 `[s, e]` 上，**二选一**满足即可：

### 1）矩形旗面（Rectangle Flag）

- `parallel ≤ 0.10`（上下沿近似平行，方向可微倾）
- `0.85 ≤ W_end/W_start ≤ 1.15`（宽度基本不变；取 `W_end = median(W_t最后25%)`，`W_start = median(W_t最初25%)`）

### 2）三角/收敛旗（Triangle/Pennant）

- `converge ≤ 0.75`（后半段宽度较前半段**减少 ≥25%**）
- 对斜率**不强约束**（避免过拟合）；可选加一条：`|slope(U)|、|slope(L)|` 不必同时很大

> 这样做只依赖“**宽度是否收敛**”来区分三角旗，足够鲁棒、实现简单。

------

## 四、触碰与驻留（轻量质量校验）

- **驻留率**：`price_inside_ratio = 价格位于 [L_t, U_t] 的根数 / FlagBars ≥ 0.80`
- **触碰数**：上下沿各至少 1 次“近触碰”（与边界距离 ≤ `0.2×ATR14`）

> 这两条能显著减少偶然窗口的误判，计算也简单。

------

## 五、突破确认（顺势）

对多头旗：

- **价**：收盘有效上破 `U_t`，要求 `close ≥ U_t + 0.1×ATR14`（或“破后1-3根回踩不破”）
- **量**：放量倍数 `Vol_burst = volume[b]/mean(V[s:e]) ≥ 1.5` 且 `volume[b] ≥ VOL20`

对空头旗对称处理（下破 `L_t`）。

------

## 六、极简扫描伪代码（O(N)，少超参）

```
pseudo复制编辑# 已有旗杆 [t0,t1], D=+1/-1
PoleTR = mean(TR[t0:t1]); PoleVol = mean(V[t0:t1]); PoleAmp = |close[t1]-open[t0]|

for s = t1+1 .. t1+Lookahead:
  for e = s+2 .. min(s+MaxFlagBars, t1+MaxLookahead):
    ATR_ratio = mean(TR[s:e]) / PoleTR
    Vol_ratio = mean(V[s:e]) / PoleVol
    Retrace   = (maxH[s:e]-minL[s:e]) / PoleAmp
    if not(ATR_ratio<=0.70 and Vol_ratio<=0.80 and Retrace<=0.45): continue

    U = rolling_q(high[s:e], 0.95, k)
    L = rolling_q(low [s:e], 0.05, k)
    W = U - L
    width_norm = median(W)/PoleAmp
    if not(0.15 <= width_norm <= 0.45): continue

    parallel = |slope(U)-slope(L)| / ATR14_per_bar
    converge = median(W[last25%]) / median(W[first25%])
    inside   = ratio(price in [L,U])  # ≥ 0.80 ?
    touches  = touches_count(U,L, tolerance=0.2*ATR14) # each side ≥1 ?

    is_rect  = (parallel <= 0.10) and (0.85 <= median(W[last25%])/median(W[first25%]) <= 1.15)
    is_tri   = (converge <= 0.75)
    if inside>=0.80 and touches and (is_rect or is_tri):
        record_flag(s,e, type = is_rect ? "rectangle" : "triangle")
        goto BREAKOUT

BREAKOUT:
for t = e+1 .. e+MaxWait:
  if D>0 and close[t] >= U_t + 0.1*ATR14 and volume[t]/mean(V[s:e])>=1.5 and volume[t]>=VOL20:
      mark_breakout(t, "up"); break
  if D<0 and close[t] <= L_t - 0.1*ATR14 and 同量能条件:
      mark_breakout(t, "down"); break
```

**默认参数（开箱即用）**

- `k=8`；`MaxFlagBars=min(20, 2*PoleBars)`；`MaxWait=MaxFlagBars`
- 超参仅 6 个：`ATR_ratio≤0.70、Vol_ratio≤0.80、Retrace≤0.45、width_norm∈[0.15,0.45]、parallel≤0.10、converge≤0.75`

------

## 七、为什么这套简单且不易过拟合

- **统一刻画**：矩形与三角都用同一“分位通道”表示，只看“平行度”和“宽度收敛度”两件事。
- **以比值为主**：全部按“相对旗杆”与 ATR 归一，跨品种跨周期迁移性强。
- **少量门槛**：6 个稳定阈值即可跑通；无需形态打分、聚类或复杂回归。
- **稳健统计**：分位数、滚动中位数对极端点不敏感；避免细节拟合。

------

## 八、可选的轻量自适应（两处替换）

若要自校准，只把两类常数替换为**滚动分位阈**（用过去 N=200 根或过去 M 个已验证旗面）：

- `ATR_ratio ≤ p70(历史ATR_ratio)`、`Vol_ratio ≤ p70(...)`、`Retrace ≤ p70(...)`
- `parallel ≤ p60(历史parallel)`、`converge ≤ p60(历史converge)`、`width_norm ∈ [p20, p80]`

------



# 方案二



### **统一的旗面识别体系：一个两阶段的过滤与分类系统**

这个系统的核心思想是：
*   **第一阶段：本质过滤** - 首先，我们不关心形态是方的还是尖的，只关心它是否具备“盘整”的内在本质。这通过方案二的四大核心指标来完成。
*   **第二阶段：几何分类** - 对于通过了第一阶段本质过滤的候选区间，我们再对其进行几何形态分析，将其精确分类为“矩形旗面”、“三角旗面”，或者因形态不规则而将其淘汰。

---

### **第一阶段：通用前提条件（旗面的“本质”过滤）**

无论最终是哪种旗面，任何一个有效的候选区间都**必须首先满足**方案二定义的“收缩”四大核心原则。这是我们识别系统的“通用入口”。

| 指标 (Metric)                        | 计算公式 / 定义                     | 建议阈值        |
| :----------------------------------- | :---------------------------------- | :-------------- |
| **1. 时长比例 (Duration Ratio)**     | `旗面 K 线数 / 旗杆 K 线数`         | `1.0 ≤ x ≤ 5.0` |
| **2. 回撤深度 (Retracement Depth)**  | `旗面对旗杆的回撤幅度 / 旗杆总幅度` | `≤ 0.50`        |
| **3. 量能收缩 (Volume Contraction)** | `旗面区间均量 / 旗杆区间均量`       | `≤ 0.6`         |
| **4. 波动下降 (Volatility Drop)**    | `旗面区间均 ATR / 旗杆区间均 ATR`   | `≤ 0.7`         |

> **只有通过了以上所有四项测试的K线区间，才有资格进入下一阶段的几何形态分类。**

---

### **第二阶段：精确的几何形态分类器**

对于通过了第一阶段的 `potential_flag` 区间，我们现在来判断它的具体形状。

**通用准备步骤：拟合上下轨道线**
我们统一使用线性回归方法，对候选区间的所有K线高点和低点进行拟合。
*   `upper_line = linear_regression(highs(potential_flag))`
*   `lower_line = linear_regression(lows(potential_flag))`

接下来，我们建立一个决策树，依次检查它是三角旗还是矩形旗。

#### **决策路径 1：优先识别“三角旗面 (Pennant)”**

三角旗的形态约束更强，我们优先检查。

| 指标 (Metric)         | 计算公式 / 定义               | 建议阈值 (以牛旗为例)            |
| :-------------------- | :---------------------------- | :------------------------------- |
| **A. 通道收敛率**     | `通道末端宽度 / 通道初始宽度` | `≤ 0.65`                         |
| **B. 斜率方向性**     | 检查上下轨斜率的正负号关系    | `上轨斜率 < 0` 且 `下轨斜率 > 0` |
| **C. 形态中轴线斜率** | `(上轨斜率 + 下轨斜率) / 2`   | `≤ 0`                            |

*   **如果一个候选区间同时满足 A、B、C 三个条件，它就被成功识别并标记为【三角旗面】。**
*   **如果不满足，我们进入决策路径 2。**

#### **决策路径 2：识别“矩形旗面 (Flag)”**

如果它不是一个收敛的三角形，我们再检查它是否是一个平行的矩形。

| 指标 (Metric)       | 计算公式 / 定义             | 建议阈值 (以牛旗为例)                          |
| :------------------ | :-------------------------- | :--------------------------------------------- |
| **A. 通道平行度**   | `abs(上轨斜率 - 下轨斜率)`  | `≤ 0.15 × ATR14 / Bar` (推荐) 或一个小的绝对值 |
| **B. 通道整体斜率** | `(上轨斜率 + 下轨斜率) / 2` | `≤ 0` (理想)                                   |

*   **如果一个候选区间满足 A 和 B 两个条件，它就被成功识别并标记为【矩形旗面】。**
*   **如果不满足，则该候选区间被淘汰。** 它虽然满足了“盘整”的内在收缩特征，但没有形成规整的几何形态，属于“不规则整理”，为保证信号质量，我们予以放弃。

---

### **整合后的算法流程（伪代码）**

```pseudo
// 假设 flagpole_list 是已识别的旗杆列表
for each flagpole in flagpole_list:
    
    // 搜索窗口
    search_window = data.after(flagpole).limit(30)
    
    // 滑动枚举潜在旗面区间
    for i from 3 to len(search_window):
        potential_flag = search_window[0:i]
        
        // ================= STAGE 1: 核心本质过滤 =================
        duration_ratio = len(potential_flag) / len(flagpole)
        retrace_depth  = calculate_retrace(flagpole, potential_flag)
        volume_ratio   = avg(volume(potential_flag)) / avg(volume(flagpole))
        atr_ratio      = avg(atr(potential_flag)) / avg(atr(flagpole))
        
        is_consolidation = (duration_ratio >= 1.0 and duration_ratio <= 5.0) and \
                           (retrace_depth <= 0.5) and \
                           (volume_ratio <= 0.6) and \
                           (atr_ratio <= 0.7)
                           
        if not is_consolidation:
            continue // 连盘整的基本特征都不满足，直接跳过

        // ================= STAGE 2: 几何形态分类 =================
        upper_line = linear_regression(highs(potential_flag))
        lower_line = linear_regression(lows(potential_flag))
        
        // --- 决策路径 1: 检查是否为三角旗 ---
        is_pennant = check_is_pennant(upper_line, lower_line) // 封装的函数，内部实现三项检查
        
        if is_pennant:
            record_pattern(flagpole, potential_flag, type="Pennant")
            // 找到后可根据策略决定是继续寻找更长的形态还是跳出
            continue
            
        // --- 决策路径 2: 检查是否为矩形旗 ---
        is_rectangular_flag = check_is_rectangular_flag(upper_line, lower_line) // 封装的函数
        
        if is_rectangular_flag:
            record_pattern(flagpole, potential_flag, type="Rectangular_Flag")
            continue
            
        // --- 如果两者都不是，则为不规则整理，自动被忽略 ---
```

### **结论与优势**

通过这个统一的、两阶段的识别体系，您将获得一个非常强大和清晰的系统：

1.  **逻辑清晰，层层递进**：先判断“是不是盘整”，再判断“是什么形状的盘整”。这符合人类的认知逻辑，也让代码结构非常清晰。
2.  **效率高**：将计算量最大的几何拟合放在了核心指标过滤之后，避免了对大量无效区间的冗余计算。
3.  **分类明确**：系统能够输出明确的形态分类（三角旗、矩形旗），这对于后续采取不同的交易策略（例如，对更具爆发力的三角旗使用更激进的仓位）非常有价值。
4.  **鲁棒性强**：通过淘汰“不规则整理”，系统专注于识别教科书式的、成功率更高的经典形态，有效过滤了市场噪声，提升了信号的整体质量。