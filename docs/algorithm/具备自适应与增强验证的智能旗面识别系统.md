## **具备自适应与增强验证的智能旗面识别系统**

**核心理念：**本系统旨在通过一个严谨、动态的流程，识别出最高质量的旗面形态。它摒弃了静态的、需要手动调优的硬编码规则，代之以能够**自我校准的动态基线**和**更深刻的形态本质验证**，从而实现跨市场、跨周期的稳定表现。

**核心流程：**

*   **步骤零：动态基线预计算** -> **阶段一：盘整本质过滤** -> **阶段二：稳健几何分类** -> **阶段三：增强质量校验** -> **最终突破确认**

---

### **步骤零：动态基线的预计算与滚动更新**

在启动识别流程前，系统首先需要建立一个“历史参照系”，用于生成动态阈值。

*   **数据源**：使用过去 `N` 根K线（建议 `N=500`）或过去 `M` 个已成功识别的形态（建议 `M=50`）作为统计样本。
*   **计算方法**：对历史样本中的各项指标（如下表所列），计算其**百分位数 (Percentile)**。这些百分位数值将作为我们动态的“标尺”。
*   **更新机制**：该基线可以每日更新一次，或以滚动方式（每根新K线进来，剔除最旧的K线）进行实时更新，以适应市场的持续演变。

---

### **阶段一：盘整本质过滤 (使用动态阈值)**

**目标**：快速、准确地筛选出具备“能量收缩”本质的候选区间。

对于候选区间 `[s, e]`，必须**同时满足**以下所有条件：

| 指标 (Metric)           | 计算方法                            | 自适应阈值 (Adaptive Threshold)        |
| :---------------------- | :---------------------------------- | :------------------------------------- |
| **1. 时长比例**         | `(e - s + 1) / (t1 - t0 + 1)`       | `∈ [0.5, 3.0]` (此项可固定)            |
| **2. 回撤深度**         | `(maxH[s:e] - minL[s:e]) / PoleAmp` | `≤ P75(历史回撤深度)`                  |
| **3. 量能收缩**         | `mean(Volume[s:e]) / PoleVol`       | `≤ P80(历史量能收缩比)`                |
| **4. 波动下降**         | `mean(ATR[s:e]) / PoleATR`          | `≤ P75(历史波动下降比)`                |
| **5. 【增强】量能趋势** | 对`Volume[s:e]`做线性回归的斜率     | `slope_vol ≤ 0` (成交量整体呈下降趋势) |

> **P_k(·)** 代表k百分位数。例如，`P75(历史回撤深度)` 表示当前回撤深度必须小于历史上75%的情况。

---

### **阶段二：稳健几何分类 (使用动态阈值)**

**目标**：对通过第一阶段的候选区间，进行抗噪声的几何形态分类。

**1. 构建与检查分位通道**
*   构建上沿 `U_t` (95%分位) 和下沿 `L_t` (5%分位)。
*   计算归一化宽度 `width_norm = median(U_t - L_t) / PoleAmp`。
*   **自适应宽度检查**: `width_norm` 必须位于 `[P20(历史宽度), P80(历史宽度)]` 区间内。

**2. 并行判定几何形态**
*   计算**平行度 (Parallelism)** 和 **收敛度 (Convergence)**。
*   进行二选一判定：
    *   **矩形旗面**: `parallel ≤ P60(历史平行度)` 且 `converge_ratio` 在 `[0.85, 1.15]` 之间。
    *   **三角旗面**: `converge_ratio ≤ P60(历史收敛度)`。

---

### **阶段三：增强质量校验 (Enhanced Quality Validation)**

**目标**：对已分类的形态进行最终的、严格的质量“终检”。

必须**同时满足**以下所有增强版条件：

1.  **驻留率 (Residency Rate)**
    *   **定义**: `价格位于 [L_t, U_t] 的K线数 / 总K线数 ≥ 0.80`。

2.  **增强版触碰判断 (Enhanced Touch Validation)**
    *   **最小触碰数**: `上轨触碰数 ≥ 2` **且** `下轨触碰数 ≥ 2`。
    *   **触碰分布均衡**: 在旗面的**后半段** (`[s + len/2, e]`)，**上下轨必须各有至少一次**有效触碰。

> **说明**：这项增强校验确保了通道在整个生命周期内都对价格形成持续且均衡的约束力，极大地过滤掉了“伪装”成旗形的无效形态。

---

### **最终确认：顺势突破**

只有通过全部三个阶段高级筛选的形态，才会进入突破监控。

*   **价格突破**: 多头旗要求收盘价有效上破 `U_t` (`close ≥ U_t + 0.1 × ATR14`)。
*   **量能爆发**: 突破K线的成交量 `Vol_break` 需满足 `Vol_break / mean(Volume[s:e]) ≥ 1.5` 且 `Vol_break` 大于近期均量（如 `VOL20`）。

---

### **完整算法伪代码（最终版）**

```pseudo
# ================= STEP 0: PRE-COMPUTATION =================
# 假设 dynamic_thresholds 对象已通过历史数据计算好
# dynamic_thresholds.retrace_p75, .vol_ratio_p80, .width_p20, .width_p80, etc.

# ================= MAIN LOOP =================
for each flagpole in flagpole_list:
    # ... 枚举潜在旗面区间 potential_flag [s, e] ...
    
    // ================= STAGE 1: ESSENCE FILTER (ADAPTIVE) =================
    retrace_depth  = (max(H[s:e])-min(L[s:e])) / PoleAmp
    volume_ratio   = mean(V[s:e]) / PoleVol
    atr_ratio      = mean(ATR[s:e]) / PoleATR
    volume_slope   = linear_regression_slope(V[s:e])

    is_consolidation = (retrace_depth <= dynamic_thresholds.retrace_p75) and \
                       (volume_ratio <= dynamic_thresholds.vol_ratio_p80) and \
                       (atr_ratio <= dynamic_thresholds.atr_ratio_p75) and \
                       (volume_slope <= 0)
    
    if not is_consolidation: continue

    // ================= STAGE 2: GEOMETRIC CLASSIFIER (ADAPTIVE) =================
    U = rolling_q(high[s:e], 0.95); L = rolling_q(low[s:e], 0.05)
    W = U - L
    width_norm = median(W) / PoleAmp
    
    if not (dynamic_thresholds.width_p20 <= width_norm <= dynamic_thresholds.width_p80): continue
        
    parallel = calculate_parallelism(U, L)
    converge = median(W_last_half) / median(W_first_half)

    is_rect = (parallel <= dynamic_thresholds.parallel_p60) and (0.85 <= converge <= 1.15)
    is_tri  = (converge <= dynamic_thresholds.converge_p60)
        
    if not (is_rect or is_tri): continue
    
    // ================= STAGE 3: QUALITY VALIDATION (ENHANCED) =================
    residency_ratio = calculate_residency(close[s:e], U, L)
    touches = count_touches_distributed(high[s:e], low[s:e], U, L) // 这是一个新函数

    is_high_quality = (residency_ratio >= 0.80) and \
                      (touches.upper_total >= 2) and (touches.lower_total >= 2) and \
                      (touches.upper_second_half >= 1) and (touches.lower_second_half >= 1)

    if is_high_quality:
        // **最终确认成功! 记录一个经得起考验的高质量旗面**
        pattern_type = "rectangle" if is_rect else "triangle"
        record_premium_flag(s, e, pattern_type)
        
        // 进入突破监控
        check_for_breakout_after(e, U, L, mean(V[s:e]))
```

这个最终方案代表了一套非常成熟和专业的算法设计思路，它将是您进行量化交易策略开发时一个极为坚实的基础。